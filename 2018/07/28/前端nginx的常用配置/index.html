<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="peiqixin,peiqixin@gmail.com"><title>前端nginx的常用配置 · ToPeas-技术博客</title><meta name="description" content="Nginx（发音同engine x）是一个异步框架的 Web服务器，也可以用作反向代理，负载平衡器 和 HTTP缓存。
平时在作为一个前端，在工作里面需要使用的nginx的时候还是挺多，也用不到到多高深，能启动，做个反向代理，解决跨域问题，静态资源的服务器，能关闭，也就能满足大部分需求了。负载均衡什"><meta name="keywords" content="node,vue,front-end,full-stack,"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.jpg" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="https://www.googletagmanager.com/gtag/js?id=UA-119881931-1" async></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date())
gtag('config', 'UA-119881931-1')
</script></head><body><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>前端nginx的常用配置</a></h3></div><div class="post-content"><p>Nginx（发音同engine x）是一个异步框架的 Web服务器，也可以用作反向代理，负载平衡器 和 HTTP缓存。</p>
<p>平时在作为一个前端，在工作里面需要使用的nginx的时候还是挺多，也用不到到多高深，能启动，做个反向代理，解决跨域问题，静态资源的服务器，能关闭，也就能满足大部分需求了。负载均衡什么听起来很高端，对于nginx来说，你配置个低配版的负载均衡还是很容易的。接下来就大概说说nginx的配置。</p>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>Nginx 的使用基本都是做一些配置项，下面来介绍 Nginx 相关的配置。</p>
<p>Nginx 的配置文件在nginx/conf/nginx.conf，打开它后可以看到有一些基本的配置模版。</p>
<p>基本上作为一个前端来说其他的配置都用不上。查看nginx配置的时候，只用关心配置sever 括号里面的内容就可以了。</p>
<h3 id="nginx的基本语法"><a href="#nginx的基本语法" class="headerlink" title="nginx的基本语法"></a>nginx的基本语法</h3><ol>
<li>属性名 [空格] 属性值 分号</li>
<li><h1 id="后面的内容表示注释"><a href="#后面的内容表示注释" class="headerlink" title="后面的内容表示注释"></a>后面的内容表示注释</h1></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # Nginx 监听端口号</span><br><span class="line">    listen       80;</span><br><span class="line"></span><br><span class="line">    # 服务器的名字，默认为 localhost，你也可以写成 aotu.jd.com，这样子就可以通过 aotu.jd.com 来访问</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    # 代码放置的根目录</span><br><span class="line">    root /var/www/;</span><br><span class="line">    # 编码</span><br><span class="line">    charset utf-8;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        # index 字段声明了解析的后缀名的先后顺序</span><br><span class="line">        # 下面匹配到/的时候默认找后缀名为 php 的文件，找不到再找 html，再找不到就找 htm</span><br><span class="line">        index index.php index.html index.htm;</span><br><span class="line">        # 自动索引</span><br><span class="line">        autoindex on;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 404 页面跳转到 404.html，相对于上面的 root 目录</span><br><span class="line">    error_page  404/404.html;</span><br><span class="line">    # 403 页面跳转到 403.html，相对于上面的 root 目录</span><br><span class="line">    error_page  403/403.html;</span><br><span class="line">    # 50x 页面跳转到 50x.html</span><br><span class="line">    error_page  500 502 503 504/50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：Nginx 的配置项写法是第一个是配置项名称，其后面空格接值，最后以分号结束。上面的配置的意思就是：访问 <a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> 的时候会在 /var/www/ 下面找 index.php 文件，如果没有找到就找 index.html，如果再没有找到那就找 index.htm，如果还是没有找到的话就 404 跳转到 404.html，如果你刚好将 /var/www/ 设置为 root 用户访问的话，那么就会直接无访问权限 403 跳转到 403.html。</p>
<h2 id="路由匹配规则"><a href="#路由匹配规则" class="headerlink" title="路由匹配规则"></a>路由匹配规则</h2><h3 id="location指令的语法"><a href="#location指令的语法" class="headerlink" title="location指令的语法"></a>location指令的语法</h3><blockquote>
<p>location [=|~|~*|^~|@] /uri/ { … } 或 location @name { … }</p>
</blockquote>
<h3 id="location指令分为两种匹配模式"><a href="#location指令分为两种匹配模式" class="headerlink" title="location指令分为两种匹配模式"></a>location指令分为两种匹配模式</h3><ol>
<li>普通字符串匹配：以=开头或开头无引导字符（～）的规则 </li>
<li>正则匹配：以～或～*开头表示正则匹配，~*表示正则不区分大小写</li>
</ol>
<blockquote>
<ul>
<li>=     严格匹配。如果请求匹配这个location，那么将停止搜索并立即处理此请求</li>
<li>~         区分大小写匹配(可用正则表达式)</li>
<li>~*       不区分大小写匹配(可用正则表达式)</li>
<li>!~       区分大小写不匹配</li>
<li>!~*     不区分大小写不匹配</li>
<li>^~      如果把这个前缀用于一个常规字符串,那么告诉nginx如果路径匹配那么不测试正则表达式表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录。</li>
</ul>
</blockquote>
<h3 id="location匹配url的规则"><a href="#location匹配url的规则" class="headerlink" title="location匹配url的规则"></a>location匹配url的规则</h3><p>当<code>nginx</code>收到一个请求后，会截取请求的<code>uri</code>部份，去搜索所有location指令中定义的<code>uri</code>匹配模式。在server模块中可以定义多个location指令来匹配不同的url请求，多个不同location配置的URI匹配模式。</p>
<p>总体的匹配原则是：先匹配普通字符串模式，再匹配正则模式。只识别URI部份，例如请求为：<code>/test/abc/user.do?name=xxxx</code><br>一个请求过来后，Nginx匹配这个请求的流程如下： </p>
<ol>
<li>先查找是否有=开头的精确匹配，如：location = /test/abc/user.do { … } </li>
<li>再查找普通匹配，以 最大前缀 为原则，如有以下两个location，则会匹配后一项 <ul>
<li>location /test/ { … } </li>
<li>location /test/abc { … } </li>
</ul>
</li>
<li>匹配到一个普通格式后，搜索并未结束，而是暂存当前匹配的结果，并继续搜索正则匹配模式 </li>
<li>所有正则匹配模式location中找到第一个匹配项后，就以此项为最终匹配结果<br>所以正则匹配项匹配规则，受定义的前后顺序影响，但普通匹配模式不会 </li>
<li>如果未找到正则匹配项，则以3中缓存的结果为最终匹配结果 </li>
<li>如果一个匹配都没搜索到，则返回404</li>
</ol>
<p>举几个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location = /                 &#123; 规则1 &#125;</span><br><span class="line">location /                   &#123; 规则2 &#125;</span><br><span class="line">location /static/            &#123; 规则3 &#125;</span><br><span class="line">location ^~ /images/         &#123; 规则4 &#125;</span><br><span class="line">location ~* \.(jpg|png)$     &#123; 规则5 &#125;</span><br><span class="line"></span><br><span class="line"># 访问</span><br><span class="line"># /               -&gt; 规则1</span><br><span class="line"># /api            -&gt; 规则2</span><br><span class="line"># /static/index.html  -&gt; 规则3</span><br><span class="line"># /static/a.png   -&gt; 规则5</span><br><span class="line"># /images/a.html   -&gt; 规则4</span><br><span class="line"># /images/a.png    -&gt; 规则4</span><br><span class="line"># /a.png          -&gt; 规则5</span><br></pre></td></tr></table></figure>
<p>说明：<code>=/ { … }</code> 与 <code>location / { … }</code> 的差别：前一个是精确匹配，只响应/请求，所有/xxx或/xxx/xxxx类的请求都不会以前缀的形式匹配到它 ,后一个是只要以 / 为前缀的请求都会被匹配到。如：<code>/abc</code> ，<code>/test/abc</code>， <code>/test/abc/aaaa</code>。前3个应该都没问题，第四个根据上面的匹配规则，<code>/static/a.png</code>先首先匹配到规则3（最大前缀原则），但是这是个普通匹配，所以还会继续的往下找，然后匹配到正则表达式规则5。第五，六个虽然是普通匹配，但是<code>^~</code>匹配到这里就已经结束了。匹配不到规则5。第七个也简单。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="1-alias与root的区别"><a href="#1-alias与root的区别" class="headerlink" title="1  alias与root的区别"></a>1  alias与root的区别</h3><p>root    实际访问文件路径会拼接URL中的路径<br>alias   实际访问文件路径不会拼接URL中的路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /sta/ &#123;  </span><br><span class="line">   alias /usr/local/nginx/html/static/;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求：<a href="http://test.com/sta/sta1.html" target="_blank" rel="noopener">http://test.com/sta/sta1.html</a><br>实际访问：/usr/local/nginx/html/static/sta1.html 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /tea/ &#123;  </span><br><span class="line">   root /usr/local/nginx/html/;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求：<a href="http://test.com/tea/tea1.html" target="_blank" rel="noopener">http://test.com/tea/tea1.html</a><br>实际访问：/usr/local/nginx/html/tea/tea1.html 文件</p>
<h3 id="2-last-和brack关键字的区别"><a href="#2-last-和brack关键字的区别" class="headerlink" title="2 last 和brack关键字的区别"></a>2 last 和brack关键字的区别</h3><p>（1）last 和 break 当出现在location 之外时，两者的作用是一致的没有任何差异</p>
<p>（2）last 和 break 当出现在location 内部时：</p>
<p>last        使用了last 指令，rewrite 后会跳出location 作用域，重新开始再走一次刚才的行为<br>break    使用了break 指令，rewrite后不会跳出location 作用域，它的生命也在这个location中终结</p>
<h3 id="根据设备访问移动端还是pc端。"><a href="#根据设备访问移动端还是pc端。" class="headerlink" title="根据设备访问移动端还是pc端。"></a>根据设备访问移动端还是pc端。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    set $mobile_rewrite do_not_perform;</span><br><span class="line">    if ($http_user_agent ~* &quot;(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino&quot;) &#123;</span><br><span class="line">        set $mobile_rewrite perform;</span><br><span class="line">    &#125;</span><br><span class="line">    if ($http_user_agent ~* &quot;^(1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-)&quot;) &#123;</span><br><span class="line">        set $mobile_rewrite perform;</span><br><span class="line">    &#125;</span><br><span class="line">    if ($http_cookie ~ &apos;gotopc=true&apos;) &#123;</span><br><span class="line">        set $mobile_rewrite do_not_perform;</span><br><span class="line">    &#125;</span><br><span class="line">    location = / &#123;</span><br><span class="line">        if ($mobile_rewrite = perform) &#123;</span><br><span class="line">            root /data/www/html/phone;</span><br><span class="line">        &#125;</span><br><span class="line">        if($mobile_rewrite != perform)&#123;</span><br><span class="line">            root /data/www/html/pc;</span><br><span class="line">        &#125;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">### 前端单页应用history路由配置</span><br></pre></td></tr></table></figure>
<p>location / {<br>        try_files $uri $uri/ /index.html;</p>
<blockquote>
<p>引用</p>
</blockquote>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其作用是按顺序检查文件是否存在，返回第一个找到的文件或文件夹（结尾加斜线表示为文件夹），如果所有的文件或文件夹都找不到，会进行一个内部重定向到最后一个参数。</span><br><span class="line"></span><br><span class="line">需要注意的是，只有最后一个参数可以引起一个内部重定向，之前的参数只设置内部URI的指向。最后一个参数是回退URI且必须存在，否则会出现内部500错误。命名的location也可以使用在最后一个参数中。</span><br><span class="line"></span><br><span class="line">### 临时跳转</span><br></pre></td></tr></table></figure></p>
<p>location /v1/ {<br>    return 302 <a href="http://aotu.jd.com/v2/" target="_blank" rel="noopener">http://aotu.jd.com/v2/</a>;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">有时候应用升级了，但是还是有用户会访问 v1 版本，为了方便过渡，可以使用临时转跳的方式，让 v1 的用户跳转到 v2 上。</span><br><span class="line"></span><br><span class="line">### 反向代理</span><br></pre></td></tr></table></figure></p>
<p>server {<br>        listen 80;<br>        server_name localhost;<br>        location / {<br>            proxy_pass <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>;<br>        }<br>}<br><code>`</code><br>比如你的服务器只开放80端口出去，但是你的起的node服务是在8080端口，那么你就用的上nginx的反向代理功能。当用户访问你的服务器80端口的时候，nginx会把请求转发到8080端口，经过8080端口服务的处理请求，把响应又转发给nginx，nginx再把这个响应返回给用户，但是看起来好像是服务器的80端口的服务响应了请求一样。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-calendar"></i><span class="date">创建时间 2018-07-28 05:41</span><i class="fa fa-calendar-o"></i><span class="date">更新时间 2018-07-28 05:44</span><i class="fa fa-tag"></i><a class="tag" href="/tags/nginx/" title="nginx">nginx </a></div></div></div></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>